# 区域生成功能设计文档

## 1. 功能概述

区域生成功能是工厂布局导入系统的核心组件，负责创建和管理工厂内的各种功能区域。该功能支持多边形和矩形区域的创建，具有智能的紧邻边界处理、区域着色和边界胶带生成功能，确保区域之间的精确划分和可视化效果。

## 2. 设计思路

### 2.1 核心设计理念
- **紧邻边界处理**：智能处理相邻区域的共享边界
- **区域着色管理**：为不同区域分配不同的颜色标识
- **边界胶带生成**：在区域边界生成可视化胶带
- **容错机制**：完善的错误处理和参数验证

### 2.2 区域类型分类
1. **多边形区域**：支持任意形状的多边形区域
   - 灵活的点集定义
   - 复杂的几何形状支持
2. **矩形区域**：简化的矩形区域
   - 四点定义
   - 自动点排序处理

### 2.3 处理流程
1. **数据验证**：检查区域数据的有效性
2. **紧邻检测**：检测相邻区域的共享边界
3. **区域创建**：根据形状类型创建区域
4. **边界处理**：处理区域间的共享边界
5. **区域着色**：为区域分配颜色
6. **胶带生成**：在区域边界生成胶带

## 3. 模块结构

### 3.1 ZoneBuilder模块

#### 主要功能
- 批量区域导入
- 紧邻边界处理
- 区域着色管理
- 边界胶带生成

#### 核心函数说明

**`import_zones(zones_data, parent_group)`**
- **作用**：批量导入所有区域
- **参数**：区域数据数组、父组对象
- **前置条件**：区域数据包含有效的shape信息

**`create_indoor_zones_floor(parent_group, zones_data, shared_boundaries)`**
- **作用**：创建室内区域地面着色
- **参数**：父组、区域数据、共享边界信息
- **前置条件**：区域已创建完成

**`hide_base_plane_and_edges(zone_group)`**
- **作用**：隐藏区域的基础平面和边缘线
- **参数**：区域组对象
- **前置条件**：区域组存在且有效

## 4. 配置参数

### 4.1 区域颜色配置
```ruby
# 区域颜色定义
ZONE_COLORS = [
  [255, 182, 193],  # 浅粉色
  [173, 216, 230],  # 浅蓝色
  [144, 238, 144],  # 浅绿色
  [255, 218, 185],  # 桃色
  [221, 160, 221],  # 梅红色
  [255, 255, 224],  # 浅黄色
  [240, 248, 255],  # 爱丽丝蓝
  [255, 228, 196],  # 莫卡辛色
  [245, 245, 245],  # 白烟色
  [255, 240, 245]   # 淡紫色
]

# 共享边界颜色
SHARED_BOUNDARY_COLOR = [255, 165, 0]  # 橙色
```

### 4.2 几何验证参数
```ruby
# 区域验证阈值
MIN_ZONE_POINTS = 3           # 最小区域点数
MIN_POLYGON_AREA = 0.001      # 最小多边形面积
MIN_RECTANGLE_SIZE = 0.001    # 最小矩形尺寸

# 紧邻检测参数
ADJACENCY_THRESHOLD = 0.001   # 紧邻检测距离阈值
```

### 4.3 着色参数
```ruby
# 地面着色参数
FLOOR_HEIGHT_OFFSET = 0.01    # 地面高度偏移（米）
FLOOR_THICKNESS = 0.001       # 地面厚度（米）

# 边界胶带参数
BOUNDARY_TAPE_WIDTH = 0.05    # 边界胶带宽度（米）
BOUNDARY_TAPE_HEIGHT = 0.15   # 边界胶带高度（米）
```

## 5. 前置条件

### 5.1 数据要求
- 区域数据必须包含有效的shape信息
- shape必须包含points数组（至少3个点）
- 区域ID或名称用于标识
- 支持polygon和rectangle两种形状类型

### 5.2 环境要求
- SketchUp环境已初始化
- 父组对象存在且有效
- 模型处于可编辑状态

### 5.3 依赖模块
- `Utils`模块：提供点验证、紧邻检测和几何计算
- `TapeBuilder`模块：提供边界胶带生成功能
- `MaterialManager`模块：提供材质管理功能
- SketchUp API：提供实体创建功能

## 6. 关键代码展示

### 6.1 区域导入主流程
```ruby
def self.import_zones(zones_data, parent_group)
  puts "开始导入区域，共 #{zones_data.size} 个区域"
  
  # 检测共享边界
  shared_boundaries = Utils.detect_shared_boundaries(zones_data)
  if shared_boundaries.any?
    puts "检测到 #{shared_boundaries.size} 对紧邻区域，启用优化处理"
    shared_boundaries.each do |boundary|
      puts "  - #{boundary[:zone1][:zone1_name]} 与 #{boundary[:zone2][:zone2_name]} 共享边界"
    end
  end
  
  # 记录已创建的区域，用于后续检查
  created_zones = []
  zones_data.each do |zone_data|
    begin
      puts "处理区域: #{zone_data['name'] || zone_data['id']}"
      
      # 验证区域数据完整性
      unless zone_data && zone_data["shape"]
        puts "警告: 区域缺少shape数据，跳过"
        next
      end
      
      shape = zone_data["shape"]
      unless shape["points"]
        puts "警告: 区域 #{zone_data['name'] || zone_data['id']} 缺少points数据，跳过"
        next
      end
      
      shape_type = shape["type"] || "polygon"
      puts "区域形状类型: #{shape_type}"
      
      case shape_type.downcase
      when "polygon", "多边形"
        # 使用新的紧邻处理功能
        zone_group = Utils.create_zone_with_adjacency_handling(parent_group, zone_data, created_zones)
        if zone_group
          # 隐藏基础区域平面和边缘线
          hide_base_plane_and_edges(zone_group)
          
          created_zones << zone_group
          puts "成功创建区域: #{zone_data["name"] || zone_data["id"]}"
        else
          puts "跳过创建区域: #{zone_data["name"] || zone_data["id"]} (可能存在冲突)"
        end
      when "rectangle", "矩形"
        # 对于矩形，先转换为多边形处理
        points = shape["points"].map { |point| Utils.validate_and_create_point(point) }.compact
        next if points.size != 4
        puts "矩形区域点数: #{points.size}"
        
        # 检查矩形点是否按顺序排列，如果不是则重新排序
        points = Utils.sort_rectangle_points(points)
        # 创建临时的多边形数据
        polygon_zone_data = zone_data.dup
        polygon_zone_data["shape"] = {
          "type" => "polygon",
          "points" => shape["points"]
        }
        # 使用新的紧邻处理功能
        zone_group = Utils.create_zone_with_adjacency_handling(parent_group, polygon_zone_data, created_zones)
        if zone_group
          # 隐藏基础区域平面和边缘线
          hide_base_plane_and_edges(zone_group)
          
          created_zones << zone_group
          puts "成功创建矩形区域: #{zone_data["name"] || zone_data["id"]}"
        else
          puts "跳过创建矩形区域: #{zone_data["name"] || zone_data["id"]} (可能存在冲突)"
        end
      else
        puts "不支持的区域形状类型: #{shape_type}"
      end
    rescue => e
      puts "创建区域失败: #{Utils.ensure_utf8(e.message)}"
      puts "区域数据: #{zone_data.inspect}"
      puts "错误堆栈: #{e.backtrace.join("\n")}"
    end
  end
  
  puts "区域导入完成，成功创建 #{created_zones.size} 个区域"
  
  # 生成内部区域边界胶带
  TapeBuilder.generate_zone_boundary_tapes(zones_data, parent_group)
  
  # 调用内部区域上色方法
  self.create_indoor_zones_floor(parent_group, zones_data, shared_boundaries)
end
```

### 6.2 区域地面着色
```ruby
def self.create_indoor_zones_floor(parent_group, zones_data, shared_boundaries)
  puts "【区域着色】开始生成区域地面着色..."
  
  zones_data.each do |zone_data|
    begin
      shape = zone_data["shape"]
      next unless shape && shape["points"]
      
      points = shape["points"].map { |point| Utils.validate_and_create_point(point) }.compact
      next if points.size < 3
      
      zone_name = zone_data["name"] || zone_data["id"] || "区域"
      
      # 创建区域地面
      create_zone_floor(parent_group, points, zone_name, zone_data, shared_boundaries)
      
    rescue => e
      puts "【区域着色】生成区域 #{zone_data["name"] || zone_data["id"]} 地面失败: #{Utils.ensure_utf8(e.message)}"
    end
  end
  
  puts "【区域着色】区域地面着色生成完成"
end

def self.create_zone_floor(parent_group, points, zone_name, zone_data, shared_boundaries)
  # 确保所有点的Z坐标为0
  floor_points = points.map { |pt| Geom::Point3d.new(pt.x, pt.y, 0) }
  
  # 创建区域地面
  floor_face = parent_group.entities.add_face(floor_points)
  return unless floor_face
  
  # 设置区域颜色
  zone_color = get_zone_color(zone_data, shared_boundaries)
  floor_face.material = zone_color
  floor_face.back_material = zone_color
  
  # 设置区域属性
  floor_face.set_attribute('FactoryImporter', 'zone_type', 'floor')
  floor_face.set_attribute('FactoryImporter', 'zone_name', zone_name)
  floor_face.set_attribute('FactoryImporter', 'zone_id', zone_data["id"])
  
  # 为地面添加厚度
  floor_face.pushpull(FLOOR_THICKNESS)
  
  puts "【区域着色】#{zone_name}: 地面着色生成成功"
end
```

### 6.3 紧邻边界处理
```ruby
def self.handle_adjacent_zones(zone_data, created_zones)
  # 检测与已创建区域的紧邻关系
  adjacent_zones = []
  
  created_zones.each do |existing_zone|
    if zones_are_adjacent(zone_data, existing_zone)
      adjacent_zones << existing_zone
    end
  end
  
  if adjacent_zones.any?
    puts "检测到 #{adjacent_zones.size} 个紧邻区域"
    # 处理紧邻边界
    handle_shared_boundaries(zone_data, adjacent_zones)
  end
  
  adjacent_zones
end

def self.zones_are_adjacent(zone_data, existing_zone)
  # 检查两个区域是否紧邻
  # 这里实现具体的紧邻检测逻辑
  # 可以通过比较边界线段或计算区域间距离来判断
  
  # 简化实现：检查是否有共享的边界点
  zone_points = zone_data["shape"]["points"]
  existing_points = get_zone_points(existing_zone)
  
  # 检查是否有相同的点（在容差范围内）
  zone_points.each do |zone_point|
    existing_points.each do |existing_point|
      if point_distance(zone_point, existing_point) < ADJACENCY_THRESHOLD
        return true
      end
    end
  end
  
  false
end
```

### 6.4 区域颜色分配
```ruby
def self.get_zone_color(zone_data, shared_boundaries)
  zone_id = zone_data["id"]
  
  # 检查是否是共享边界区域
  if is_shared_boundary_zone(zone_id, shared_boundaries)
    return SHARED_BOUNDARY_COLOR
  end
  
  # 根据区域ID分配颜色
  color_index = zone_id.hash.abs % ZONE_COLORS.size
  ZONE_COLORS[color_index]
end

def self.is_shared_boundary_zone(zone_id, shared_boundaries)
  shared_boundaries.any? do |boundary|
    boundary[:zone1][:zone1_id] == zone_id || boundary[:zone2][:zone2_id] == zone_id
  end
end
```

## 7. 使用流程

### 7.1 基本使用
```ruby
# 批量导入区域
zones_data = [
  {
    "id" => "zone1",
    "name" => "生产区域1",
    "shape" => {
      "type" => "polygon",
      "points" => [
        [0, 0, 0],
        [10, 0, 0],
        [10, 10, 0],
        [0, 10, 0]
      ]
    }
  }
]

ZoneBuilder.import_zones(zones_data, parent_group)
```

### 7.2 矩形区域创建
```ruby
# 创建矩形区域
rectangle_zone = {
  "id" => "zone2",
  "name" => "办公区域",
  "shape" => {
    "type" => "rectangle",
    "points" => [
      [0, 0, 0],
      [5, 0, 0],
      [5, 5, 0],
      [0, 5, 0]
    ]
  }
}

ZoneBuilder.import_zones([rectangle_zone], parent_group)
```

### 7.3 区域地面着色
```ruby
# 创建区域地面着色
ZoneBuilder.create_indoor_zones_floor(parent_group, zones_data, shared_boundaries)
```

## 8. 错误处理

### 8.1 数据验证
- 检查区域数据的完整性
- 验证shape和points的有效性
- 确保区域点数足够

### 8.2 几何验证
- 检查多边形是否有效
- 验证矩形点的顺序
- 确保区域面积合理

### 8.3 异常捕获
- 使用begin-rescue块包装主要操作
- 提供详细的错误日志
- 确保程序在出错时能够继续运行

## 9. 性能考虑

### 9.1 算法优化
- 高效的紧邻检测算法
- 优化的颜色分配策略
- 合理的几何计算

### 9.2 内存管理
- 及时清理临时变量
- 避免创建过多中间对象
- 使用适当的数据结构

### 9.3 渲染优化
- 批量处理区域创建
- 优化材质应用
- 减少不必要的几何计算

## 10. 扩展性

### 10.1 区域类型扩展
- 支持更多形状类型（圆形、椭圆形等）
- 可添加区域层级结构
- 支持区域的动态更新

### 10.2 着色系统扩展
- 支持更复杂的着色规则
- 可添加纹理和材质
- 支持动态颜色变化

### 10.3 功能扩展
- 支持区域的交互操作
- 可添加区域标签和注释
- 支持区域的统计分析

---
 