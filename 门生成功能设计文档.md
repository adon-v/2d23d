# 门生成功能设计文档

## 1. 功能概述

门生成功能是工厂布局导入系统的核心组件，负责在墙体上创建门开口和独立门的生成。该功能支持两种类型的门：墙体门（在现有墙体上开洞）和独立门（独立存在的门实体）。系统采用智能投影算法确保门与墙体的精确对齐。

## 2. 设计思路

### 2.1 核心设计理念
- **滞后创建策略**：确保墙体已存在后再创建门，避免依赖问题
- **智能投影算法**：将门坐标精确投影到墙体上，确保对齐
- **厚度自适应**：支持厚度为0的墙体和正常厚度墙体的不同处理
- **容错机制**：完善的错误处理和参数验证

### 2.2 门类型分类
1. **墙体门**：在现有墙体上创建开口
   - 零厚度墙体门：创建门面而非开口
   - 正常厚度墙体门：在墙体上挖洞
2. **独立门**（未做测试）：独立存在的门实体

### 2.3 处理流程
1. **数据验证**：检查门和墙体数据的有效性
2. **类型判断**：区分墙体门和独立门
3. **坐标投影**：将门坐标投影到墙体上
4. **几何计算**：计算门洞的精确位置和尺寸
5. **实体创建**：在SketchUp中创建门开口或门实体

## 3. 模块结构

### 3.1 DoorBuilder模块

#### 主要功能
- 批量门创建管理
- 墙体门开口生成
- 独立门实体创建
- 智能坐标投影

#### 核心函数说明

**`create_all_doors(door_data_list, parent_group)`**
- **作用**：批量创建所有门，统一管理创建流程
- **参数**：门数据列表、父组对象
- **前置条件**：墙体已创建完成，门数据包含有效的door_data和wall_data

**`create_door_opening(wall_group, wall_data, door_data, parent_group)`**
- **作用**：在墙体上创建门开口
- **参数**：墙体组、墙体数据、门数据、父组
- **前置条件**：墙体组存在，门尺寸数据有效

**`create_door_on_zero_thickness_wall(wall_group, wall_data, door_data, start_point, end_point, height)`**
- **作用**：在厚度为0的墙体上创建门面
- **参数**：墙体组、墙体数据、门数据、门起点、门终点、门高度
- **前置条件**：墙体向量有效，门尺寸合理

**`create_door_on_normal_wall(wall_group, wall_data, door_data, start_point, end_point, height)`**
- **作用**：在正常厚度墙体上创建门开口
- **参数**：墙体组、墙体数据、门数据、门起点、门终点、门高度
- **前置条件**：墙体厚度大于0，门坐标有效

**`project_point_to_wall(point, wall_start, wall_end)`**
- **作用**：将点投影到墙体上
- **参数**：待投影点、墙体起点、墙体终点
- **返回**：投影后的点坐标

**`extract_wall_thickness(wall_group, wall_data)`**
- **作用**：从墙体数据中提取厚度信息
- **参数**：墙体组、墙体数据
- **返回**：墙体厚度（英寸）

**`calculate_door_ground_points(start_point, end_point, wall_thickness)`**
- **作用**：计算门洞地面的四个角点
- **参数**：门起点、门终点、墙体厚度
- **返回**：四个角点坐标数组

**`import_independent_door(door_data, parent_group)`**
- **作用**：创建独立门实体
- **参数**：门数据、父组
- **前置条件**：门位置数据有效

## 4. 配置参数

### 4.1 门尺寸参数
```ruby
# 默认门尺寸
DEFAULT_DOOR_WIDTH = 0.9      # 默认门宽度（米）
DEFAULT_DOOR_HEIGHT = 2.0     # 默认门高度（米）
DEFAULT_DOOR_DEPTH = 0.1      # 默认门深度（米）

# 门宽度限制
MAX_REASONABLE_WIDTH = 10.0   # 最大合理门宽度（米）
MIN_DOOR_WIDTH = 0.001        # 最小门宽度（米）
```

### 4.2 墙体厚度参数
```ruby
# 默认墙体厚度
DEFAULT_WALL_THICKNESS_MM = 200    # 默认墙体厚度（毫米）
DEFAULT_WALL_THICKNESS_INCHES = 7.874  # 默认墙体厚度（英寸）

# 厚度判断阈值
ZERO_THICKNESS_THRESHOLD = 0.001   # 零厚度判断阈值（米）
```

### 4.3 几何计算参数
```ruby
# 向量长度阈值
MIN_VECTOR_LENGTH = 0.001     # 最小向量长度
MIN_WALL_LENGTH = 0.001       # 最小墙体长度

# 投影参数范围
PROJECTION_T_MIN = 0.0        # 投影参数最小值
PROJECTION_T_MAX = 1.0        # 投影参数最大值
```

## 5. 前置条件

### 5.1 数据要求
- 门数据必须包含有效的尺寸信息（size数组）
- 墙体门需要对应的墙体数据（wall_data）
- 独立门需要有效的位置信息（position）
- 所有坐标必须是有效的数值

### 5.2 环境要求
- SketchUp环境已初始化
- 父组对象存在且有效
- 墙体已创建完成（对于墙体门）
- 模型处于可编辑状态

### 5.3 依赖模块
- `Utils`模块：提供点验证、数值解析和UTF-8编码处理
- `Geom`模块：提供几何计算功能
- SketchUp API：提供实体创建和变换功能

## 6. 关键代码展示

### 6.1 智能坐标投影算法
```ruby
def self.project_point_to_wall(point, wall_start, wall_end)
  wall_vector = wall_end - wall_start
  wall_length = wall_vector.length
  
  if wall_length < 0.001
    puts "警告: 墙体长度过小，无法投影"
    return point
  end
  
  # 计算点到墙体的投影
  wall_direction = wall_vector.normalize
  point_to_wall_start = point - wall_start
  
  # 计算投影参数 t (0 <= t <= 1 表示在墙体上)
  t = point_to_wall_start.dot(wall_direction) / wall_length
  
  # 限制投影点在墙体范围内
  t = [0.0, [t, 1.0].min].max
  
  # 计算投影点
  projection_distance = t * wall_length
  projection_vector = wall_direction.clone
  projection_vector.length = projection_distance
  projected_point = wall_start + projection_vector
  
  puts "  原始点: #{point.inspect}"
  puts "  投影参数 t: #{t}"
  puts "  投影距离: #{projection_distance}"
  puts "  投影点: #{projected_point.inspect}"
  
  projected_point
end
```

### 6.2 门洞四点计算
```ruby
def self.calculate_door_ground_points(start_point, end_point, wall_thickness)
  # 计算墙体方向向量
  wall_vector = end_point - start_point
  wall_direction = wall_vector.normalize
  
  # 计算墙体法线（垂直于墙体方向和向上方向）
  wall_normal = wall_direction.cross(Geom::Vector3d.new(0, 0, 1)).normalize
  
  # 计算厚度向量
  thickness_vec = wall_normal.clone
  thickness_vec.length = wall_thickness
  
  # 计算门洞地面四点（逆时针顺序）
  ground_points = [
    start_point,                                    # 点1：起点
    start_point + thickness_vec,                    # 点2：起点+厚度
    end_point + thickness_vec,                      # 点3：终点+厚度
    end_point                                       # 点4：终点
  ]
  
  puts "  墙体方向: #{wall_direction.inspect}"
  puts "  墙体法线: #{wall_normal.inspect}"
  puts "  厚度向量: #{thickness_vec.inspect}"
  
  ground_points
end
```

### 6.3 零厚度墙体门创建
```ruby
def self.create_door_on_zero_thickness_wall(wall_group, wall_data, door_data, start_point, end_point, height)
  wall_entities = wall_group.entities
  
  # 计算墙体的方向
  wall_start = Utils.validate_and_create_point(wall_data["start"])
  wall_end = Utils.validate_and_create_point(wall_data["end"])
  
  if !wall_start || !wall_end
    puts "警告: 墙体坐标无效，无法在零厚度墙体上创建门"
    return
  end
  
  # 计算墙体方向向量
  wall_vector = wall_end - wall_start
  
  # 检查墙体向量有效性
  wall_direction = nil
  if wall_vector.length >= 0.001
    wall_direction = wall_vector.normalize
  else
    # 如果墙体向量无效，尝试从门的起点和终点推断方向
    door_vector = end_point - start_point
    
    if door_vector.length >= 0.001
      wall_direction = door_vector.normalize
      puts "警告: 墙体向量无效，使用门的方向代替"
    else
      wall_direction = Geom::Vector3d.new(1, 0, 0)
      puts "警告: 墙体向量和门的向量都无效，使用默认方向"
    end
  end
  
  # 计算门的四个角点
  door_points = [
    start_point,
    end_point,
    end_point + Geom::Vector3d.new(0, 0, height),
    start_point + Geom::Vector3d.new(0, 0, height)
  ]
  
  # 创建门组
  door_group = wall_group.entities.add_group
  door_group.name = "Door-#{door_data['id'] || 'unknown'}"
  
  # 在门的位置创建一个新面
  door_face = door_group.entities.add_face(door_points)
  
  if door_face
    door_face.material = [200, 200, 200]  # 浅灰色
    puts "在厚度为0的墙体上创建门成功"
  end
end
```

### 6.4 正常厚度墙体门创建
```ruby
def self.create_door_on_normal_wall(wall_group, wall_data, door_data, start_point, end_point, height)
  model = Sketchup.active_model
  model.start_operation("创建墙体门", true)

  # 智能投影：将门坐标投影到墙体上
  wall_start = Utils.validate_and_create_point(wall_data["start"])
  wall_end = Utils.validate_and_create_point(wall_data["end"])
  
  projected_start = project_point_to_wall(start_point, wall_start, wall_end)
  projected_end = project_point_to_wall(end_point, wall_start, wall_end)
  
  # 获取墙体厚度
  wall_thickness = extract_wall_thickness(wall_group, wall_data)
  
  # 计算门洞地面四点坐标
  ground_points = calculate_door_ground_points(projected_start, projected_end, wall_thickness)
  
  # 创建门洞面
  wall_entities = wall_group.entities
  door_base_face = wall_entities.add_face(ground_points)
  
  if door_base_face
    # 直接沿Z轴正方向挖洞
    door_base_face.pushpull(height / 0.0254)
    puts "门洞生成完成！"
  end

  model.commit_operation
rescue => e
  model.abort_operation if model
  puts "创建门失败: #{Utils.ensure_utf8(e.message)}"
end
```

## 7. 使用流程

### 7.1 基本使用
```ruby
# 批量创建所有门
door_data_list = [
  {
    door_data: { "id" => "door1", "size" => [point1, point2], "height" => 2000 },
    wall_data: { "id" => "wall1", "start" => wall_start, "end" => wall_end, "thickness" => 200 },
    parent_group: wall_group
  }
]

DoorBuilder.create_all_doors(door_data_list, parent_group)
```

### 7.2 单独创建墙体门
```ruby
# 在墙体上创建门开口
DoorBuilder.create_door_opening(wall_group, wall_data, door_data, parent_group)
```

### 7.3 创建独立门
```ruby
# 创建独立门
door_data = {
  "id" => "independent_door1",
  "position" => [x, y, z],
  "size" => [width, height, depth],
  "orientation" => 45
}

DoorBuilder.import_independent_door(door_data, parent_group)
```

## 8. 错误处理

### 8.1 数据验证
- 检查门尺寸数据的完整性
- 验证坐标点的有效性
- 确保墙体数据存在且有效

### 8.2 几何验证
- 检查向量长度是否合理
- 验证投影参数的有效性
- 确保门洞四点能形成有效面

### 8.3 异常捕获
- 使用begin-rescue块包装主要操作
- 提供详细的错误日志和调试信息
- 确保程序在出错时能够继续运行

## 9. 性能考虑

### 9.1 算法优化
- 使用高效的几何计算算法
- 避免重复的向量计算
- 合理设置数值精度阈值

### 9.2 内存管理
- 及时清理临时变量
- 避免创建过多中间对象
- 使用适当的数据结构

### 9.3 操作管理
- 使用SketchUp的操作管理（start_operation/commit_operation）
- 确保操作的原子性
- 在出错时正确回滚操作

## 10. 扩展性

### 10.1 门类型扩展
- 支持不同类型的门（单开门、双开门、推拉门等）
- 可添加门的材质和纹理
- 支持门的动画效果

### 10.2 几何算法扩展
- 支持更复杂的墙体形状
- 可添加门的装饰元素
- 支持门的自动尺寸调整

### 10.3 配置灵活性
- 支持自定义门尺寸参数
- 可调整投影算法参数
- 支持不同的单位系统

---

 