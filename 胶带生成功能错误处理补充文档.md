# 胶带生成功能错误处理补充文档

## 1. 概述

胶带生成功能涉及复杂的几何计算，包括偏移多边形生成、线段交点计算、多边形减法等操作。这些操作可能遇到各种异常情况，需要完善的错误处理机制来确保系统的稳定性和可靠性。

## 2. 主要异常类型及处理方法

### 2.1 数据验证异常

#### 2.1.1 区域数据缺失
**异常情况**：区域数据缺少shape或points信息
**处理方法**：
```ruby
# 在generate_zone_boundary_tapes中的处理
shape = zone_data["shape"]
next unless shape && shape["points"]  # 跳过无效数据

points = shape["points"].map { |point| Utils.validate_and_create_point(point) }.compact
next if points.size < 3  # 确保至少有3个有效点
```

#### 2.1.2 点坐标无效
**异常情况**：点坐标包含非数值或无效值
**处理方法**：
```ruby
# Utils.validate_and_create_point的容错处理
def self.validate_and_create_point(point_data)
  return nil unless point_data && point_data.is_a?(Array) && point_data.size >= 2
  
  begin
    x = parse_number(point_data[0])
    y = parse_number(point_data[1])
    z = parse_number(point_data[2] || 0)
    
    return nil if x.nil? || y.nil? || z.nil?
    Geom::Point3d.new(x, y, z)
  rescue => e
    puts "警告: 点坐标解析失败: #{point_data.inspect}, 错误: #{e.message}"
    nil
  end
end
```

### 2.2 几何计算异常

#### 2.2.1 向量长度过小
**异常情况**：边的方向向量长度接近零
**处理方法**：
```ruby
# 在generate_offset_polygon中的处理
edge_vector = p2 - p1
return [] if edge_vector.length < 1e-6  # 跳过过短的边

# 在calculate_normal_vector中的容错处理
def self.calculate_normal_vector(edge_vector)
  normal = Geom::Vector3d.new(-edge_vector.y, edge_vector.x, 0)
  normal.normalize
rescue
  # 如果标准化失败，返回默认单位向量
  Geom::Vector3d.new(1, 0, 0)
end
```

#### 2.2.2 线段平行或重合
**异常情况**：两条线段平行，无法计算交点
**处理方法**：
```ruby
# 在calculate_line_intersection中的处理
denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)
return nil if denom.abs < 1e-10  # 线段平行

# 在calculate_offset_polygon_intersections中的备用方案
if intersection
  polygon_points << intersection
else
  # 如果交点计算失败，使用中点
  mid_point = calculate_midpoint(prev_line[1], curr_line[0])
  polygon_points << mid_point
end
```

#### 2.2.3 偏移多边形生成失败
**异常情况**：偏移距离过大导致多边形自交或无效
**处理方法**：
```ruby
# 在generate_tape_by_offset_subtraction中的处理
large_region_points = generate_offset_polygon(points, half_width)
return unless large_region_points  # 大区域生成失败

small_region_points = generate_offset_polygon(points, -half_width)
return unless small_region_points  # 小区域生成失败

# 如果偏移失败，可以尝试减小偏移距离
def self.generate_offset_polygon_with_fallback(original_points, offset_distance)
  # 首先尝试原始偏移距离
  result = generate_offset_polygon(original_points, offset_distance)
  return result if result && result.size >= 3
  
  # 如果失败，尝试减小偏移距离
  reduced_distance = offset_distance * 0.5
  result = generate_offset_polygon(original_points, reduced_distance)
  return result if result && result.size >= 3
  
  # 如果仍然失败，返回空数组
  []
end
```

### 2.3 多边形操作异常

#### 2.3.1 多边形点数不足
**异常情况**：生成的多边形点数少于3个
**处理方法**：
```ruby
# 在subtract_polygons中的验证
def self.subtract_polygons(large_polygon, small_polygon, zone_name)
  return [] if large_polygon.size < 3 || small_polygon.size < 3
  
  # 记录警告信息
  if large_polygon.size < 3
    puts "警告: 大区域多边形点数不足: #{large_polygon.size}"
  end
  if small_polygon.size < 3
    puts "警告: 小区域多边形点数不足: #{small_polygon.size}"
  end
  
  # 简化处理：直接使用大区域作为胶带外边界，小区域作为内边界
  tape_polygon = large_polygon + small_polygon.reverse
  tape_polygon
end
```

#### 2.3.2 多边形自交
**异常情况**：偏移后的多边形出现自交
**处理方法**：
```ruby
# 检测多边形自交
def self.detect_polygon_self_intersection(points)
  return false if points.size < 4
  
  (0...points.size).each do |i|
    p1 = points[i]
    p2 = points[(i + 1) % points.size]
    
    ((i + 2)...points.size).each do |j|
      p3 = points[j]
      p4 = points[(j + 1) % points.size]
      
      # 跳过相邻边
      next if (j + 1) % points.size == i
      
      # 检查线段相交
      if line_segments_intersect(p1, p2, p3, p4)
        return true
      end
    end
  end
  
  false
end

# 如果检测到自交，尝试简化多边形
def self.simplify_polygon_if_needed(points)
  return points unless detect_polygon_self_intersection(points)
  
  puts "警告: 检测到多边形自交，尝试简化"
  # 实现多边形简化算法
  simplified_points = simplify_polygon(points)
  simplified_points
end
```

### 2.4 SketchUp API异常

#### 2.4.1 面创建失败
**异常情况**：无法在SketchUp中创建面
**处理方法**：
```ruby
# 在create_tape_face中的处理
def self.create_tape_face(tape_polygon, zone_name, parent_group, tape_layer, is_outdoor = false)
  return unless tape_polygon && tape_polygon.size >= 3
  
  # 确保所有点都是有效的
  valid_points = tape_polygon.select { |pt| pt && pt.is_a?(Geom::Point3d) }
  return unless valid_points.size >= 3
  
  # 上浮避免与区域重叠
  elevated_points = valid_points.map { |pt| Geom::Point3d.new(pt.x, pt.y, pt.z + TAPE_HEIGHT_OFFSET) }
  
  begin
    # 生成胶带面
    tape_face = parent_group.entities.add_face(elevated_points)
    return unless tape_face
    
    # 设置材质和属性
    setup_tape_face(tape_face, zone_name, tape_layer, is_outdoor)
    
    # 为胶带添加厚度
    tape_face.pushpull(TAPE_THICKNESS)
    
    puts "【胶带】#{zone_name}: 胶带生成成功"
    tape_face
    
  rescue => e
    puts "【胶带】#{zone_name}: 胶带面创建失败: #{e.message}"
    puts "  点数: #{elevated_points.size}"
    puts "  点坐标: #{elevated_points.inspect}"
    nil
  end
end
```

#### 2.4.2 层创建失败
**异常情况**：无法创建或找到胶带层
**处理方法**：
```ruby
# 在create_tape_layer中的处理
def self.create_tape_layer
  model = Sketchup.active_model
  return unless model
  
  begin
    # 查找或创建胶带层
    tape_layer = model.layers.find { |layer| layer.name == "胶带层" }
    unless tape_layer
      tape_layer = model.layers.add("胶带层")
      puts "【胶带】创建胶带层成功"
    end
    
    tape_layer
  rescue => e
    puts "【胶带】创建胶带层失败: #{e.message}"
    # 返回默认层
    model.layers[0]
  end
end
```

## 3. 关键错误处理函数

### 3.1 几何验证函数
```ruby
# 验证多边形有效性
def self.validate_polygon(points, zone_name)
  return false unless points && points.is_a?(Array)
  return false if points.size < 3
  
  # 检查点是否有效
  valid_points = points.select { |pt| pt && pt.is_a?(Geom::Point3d) }
  if valid_points.size < 3
    puts "警告: #{zone_name} 有效点数不足: #{valid_points.size}"
    return false
  end
  
  # 检查多边形面积
  area = calculate_polygon_area(valid_points)
  if area < 1e-6
    puts "警告: #{zone_name} 多边形面积过小: #{area}"
    return false
  end
  
  # 检查是否自交
  if detect_polygon_self_intersection(valid_points)
    puts "警告: #{zone_name} 多边形存在自交"
    return false
  end
  
  true
end

# 计算多边形面积
def self.calculate_polygon_area(points)
  return 0 if points.size < 3
  
  area = 0
  n = points.size
  
  (0...n).each do |i|
    j = (i + 1) % n
    area += points[i].x * points[j].y
    area -= points[j].x * points[i].y
  end
  
  area.abs / 2.0
end
```

### 3.2 容错处理函数
```ruby
# 带容错的偏移多边形生成
def self.generate_offset_polygon_with_retry(original_points, offset_distance, max_retries = 3)
  retries = 0
  current_distance = offset_distance
  
  while retries < max_retries
    result = generate_offset_polygon(original_points, current_distance)
    
    if result && result.size >= 3 && validate_polygon(result, "偏移多边形")
      return result
    end
    
    # 减小偏移距离重试
    current_distance *= 0.7
    retries += 1
    puts "警告: 偏移多边形生成失败，重试 #{retries}/#{max_retries}，偏移距离: #{current_distance}"
  end
  
  puts "错误: 偏移多边形生成最终失败，使用原始多边形"
  original_points
end

# 带容错的线段交点计算
def self.calculate_line_intersection_with_fallback(p1, p2, q1, q2)
  intersection = calculate_line_intersection(p1, p2, q1, q2)
  return intersection if intersection
  
  # 如果交点计算失败，返回中点
  mid_point = calculate_midpoint(p2, q1)
  puts "警告: 线段交点计算失败，使用中点: #{mid_point.inspect}"
  mid_point
end
```

### 3.3 日志记录函数
```ruby
# 详细的错误日志记录
def self.log_tape_generation_error(zone_name, error, context = {})
  puts "【胶带错误】区域: #{zone_name}"
  puts "  错误类型: #{error.class}"
  puts "  错误信息: #{error.message}"
  puts "  错误堆栈: #{error.backtrace.first(3).join("\n    ")}"
  
  context.each do |key, value|
    puts "  #{key}: #{value}"
  end
end

# 性能监控日志
def self.log_tape_performance(zone_name, start_time, end_time, points_count)
  duration = end_time - start_time
  puts "【胶带性能】#{zone_name}: 处理 #{points_count} 个点，耗时 #{duration.round(3)} 秒"
end
```

## 4. 异常恢复策略

### 4.1 渐进式降级
```ruby
# 胶带生成的渐进式降级策略
def self.generate_tape_with_fallback(points, zone_name, parent_group, tape_layer, is_outdoor = false)
  # 策略1: 标准偏移减法
  tape_polygon = generate_tape_by_offset_subtraction(points, zone_name, parent_group, tape_layer, is_outdoor)
  return tape_polygon if tape_polygon
  
  # 策略2: 简化偏移减法
  puts "【胶带】#{zone_name}: 标准方法失败，尝试简化方法"
  tape_polygon = generate_simplified_tape(points, zone_name, parent_group, tape_layer, is_outdoor)
  return tape_polygon if tape_polygon
  
  # 策略3: 基础边界线
  puts "【胶带】#{zone_name}: 简化方法失败，生成基础边界线"
  generate_basic_boundary_line(points, zone_name, parent_group, tape_layer, is_outdoor)
end
```

### 4.2 数据清理和修复
```ruby
# 清理和修复点数据
def self.clean_and_repair_points(points, zone_name)
  # 移除重复点
  unique_points = []
  points.each do |point|
    if unique_points.empty? || point.distance(unique_points[-1]) > 1e-6
      unique_points << point
    end
  end
  
  # 确保闭合
  if unique_points.size >= 3 && unique_points.first.distance(unique_points.last) > 1e-6
    unique_points << unique_points.first
  end
  
  # 验证修复后的数据
  if unique_points.size < 3
    puts "警告: #{zone_name} 修复后点数仍不足: #{unique_points.size}"
    return nil
  end
  
  unique_points
end
```

## 5. 错误处理最佳实践

### 5.1 异常捕获层次
```ruby
# 顶层异常捕获
def self.generate_zone_boundary_tapes(zones_data, parent_group)
  puts "【胶带】开始生成区域边界胶带..."
  
  begin
    tape_layer = create_tape_layer
    
    zones_data.each_with_index do |zone_data, zone_index|
      begin
        process_single_zone_tape(zone_data, zone_index, parent_group, tape_layer)
      rescue => e
        log_tape_generation_error(zone_data["name"] || zone_data["id"], e, {
          zone_index: zone_index,
          data: zone_data.inspect
        })
        # 继续处理下一个区域
      end
    end
    
    puts "【胶带】区域边界胶带生成完成"
  rescue => e
    puts "【胶带】胶带生成过程发生严重错误: #{e.message}"
    puts "错误堆栈: #{e.backtrace.join("\n")}"
  end
end
```

### 5.2 资源清理
```ruby
# 确保资源正确清理
def self.cleanup_tape_resources(tape_face, zone_name)
  return unless tape_face
  
  begin
    # 清理相关资源
    if tape_face.deleted?
      puts "【胶带】#{zone_name}: 胶带面已被删除"
    else
      # 可以在这里添加其他清理逻辑
      puts "【胶带】#{zone_name}: 资源清理完成"
    end
  rescue => e
    puts "【胶带】#{zone_name}: 资源清理失败: #{e.message}"
  end
end
```

## 6. 监控和调试

### 6.1 性能监控
```ruby
# 性能监控装饰器
def self.with_performance_monitoring(zone_name, &block)
  start_time = Time.now
  result = block.call
  end_time = Time.now
  
  log_tape_performance(zone_name, start_time, end_time, result&.size || 0)
  result
end
```

### 6.2 调试模式
```ruby
# 调试模式开关
DEBUG_MODE = false

def self.debug_log(message)
  puts "【胶带调试】#{message}" if DEBUG_MODE
end

# 在关键函数中添加调试信息
def self.generate_offset_polygon(original_points, offset_distance)
  debug_log("开始生成偏移多边形，点数: #{original_points.size}, 偏移距离: #{offset_distance}")
  
  # ... 原有逻辑 ...
  
  debug_log("偏移多边形生成完成，结果点数: #{offset_polygon.size}")
  offset_polygon
end
```
