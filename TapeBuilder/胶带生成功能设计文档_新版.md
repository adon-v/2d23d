# 胶带生成功能设计文档

## 1. 功能概述

胶带生成功能是工厂布局导入系统的重要组件，负责在区域边界创建可视化的胶带标识。该功能通过获取区域边界点，沿边界创建具有一定宽度的平面，然后将平面拉高并应用材质，实现区域边界的直观可视化效果。

## 2. 设计思路

### 2.1 核心设计理念
- **边界提取**：从区域数据中提取边界线段
- **胶带平面生成**：沿边界线段创建具有一定宽度的平面
- **高度处理**：将胶带平面拉高到适当高度
- **材质应用**：应用专门的胶带材质
- **容错机制**：完善的错误处理和参数验证
- **冲突检测**：检测胶带位置是否已有其他实体（如墙面），避免重复创建
- **单区域处理**：每次只处理一个区域的胶带生成，确保精确控制

### 2.2 处理流程
1. **数据验证**：检查区域数据的有效性
2. **边界提取**：从区域数据中提取边界线段
3. **冲突检测**：检查每个边界线段位置是否已有实体
4. **胶带平面生成**：为每个无冲突的边界线段创建胶带平面
5. **高度处理**：将胶带平面拉高到适当高度
6. **材质应用**：应用胶带材质
7. **属性设置**：设置胶带的属性信息

## 3. 模块结构

### 3.1 TapeBuilder模块

#### 主要功能
- 单区域胶带生成
- 边界线段提取
- 冲突检测
- 胶带平面创建
- 材质应用

#### 核心函数说明

**`generate_zone_tape(zone_data, parent_group)`**
- **作用**：为单个区域生成胶带
- **参数**：区域数据、父组对象
- **前置条件**：区域数据包含有效的shape信息

**`extract_boundary_segments(zone_data)`**
- **作用**：从区域数据中提取边界线段
- **参数**：区域数据
- **返回值**：边界线段数组，每个线段包含起点和终点

**`check_segment_conflict(segment, width, parent_group)`**
- **作用**：检查边界线段位置是否已有实体
- **参数**：边界线段、胶带宽度、父组对象
- **返回值**：布尔值，表示是否存在冲突

**`create_tape_for_segment(segment, width, parent_group)`**
- **作用**：为单个边界线段创建胶带平面
- **参数**：边界线段、胶带宽度、父组对象
- **返回值**：创建的胶带面对象

**`apply_tape_material(tape_face)`**
- **作用**：应用胶带材质到胶带面
- **参数**：胶带面对象
- **前置条件**：胶带面存在且有效

## 4. 配置参数

### 4.1 胶带参数
```ruby
# 胶带配置参数
TAPE_COLOR = [255, 255, 0]  # 黄色
TAPE_WIDTH = 0.05           # 胶带宽度（米）
TAPE_HEIGHT = 0.01          # 胶带高度（米）
TAPE_ELEVATION = 0.005      # 胶带上浮高度（米）
```

### 4.2 冲突检测参数
```ruby
# 冲突检测参数
CONFLICT_DETECTION_TOLERANCE = 0.01  # 冲突检测容差（米）
CONFLICT_RAY_COUNT = 5              # 每段边界发射的射线数量
```

## 5. 前置条件

### 5.1 数据要求
- 区域数据必须包含有效的shape信息
- shape必须包含points数组（至少3个点）
- 区域ID或名称用于标识

### 5.2 环境要求
- SketchUp环境已初始化
- 父组对象存在且有效
- 模型处于可编辑状态

### 5.3 依赖模块
- `Utils`模块：提供点验证和几何计算
- `MaterialManager`模块：提供材质管理功能（可选）
- SketchUp API：提供实体创建功能

## 6. 实现方案

### 6.1 边界线段提取
从区域点集中提取所有边界线段，每个线段由两个点定义：
```ruby
def extract_boundary_segments(points)
  segments = []
  points.each_with_index do |point, i|
    next_point = points[(i + 1) % points.size]
    segments << [point, next_point]
  end
  segments
end
```

### 6.2 冲突检测
检查边界线段位置是否已有实体（如墙面）：
```ruby
def check_segment_conflict(segment, width, parent_group)
  start_point, end_point = segment
  
  # 计算线段方向向量
  direction = end_point - start_point
  length = direction.length
  
  # 计算垂直于线段的单位向量
  perpendicular = Geom::Vector3d.new(-direction.y, direction.x, 0)
  perpendicular.normalize!
  
  # 计算胶带四个角点
  half_width = width / 2.0
  p1 = start_point.offset(perpendicular, half_width)
  p2 = start_point.offset(perpendicular, -half_width)
  p3 = end_point.offset(perpendicular, -half_width)
  p4 = end_point.offset(perpendicular, half_width)
  
  # 在胶带区域内发射多条射线检测是否有实体
  has_conflict = false
  
  # 在线段上均匀分布检测点
  check_points = []
  CONFLICT_RAY_COUNT.times do |i|
    ratio = i.to_f / (CONFLICT_RAY_COUNT - 1)
    mid_point_top = p1.linear_combination(1.0 - ratio, p4, ratio)
    mid_point_bottom = p2.linear_combination(1.0 - ratio, p3, ratio)
    check_points << [mid_point_top, mid_point_bottom]
  end
  
  # 检查每个点对之间是否有实体
  model = Sketchup.active_model
  check_points.each do |point_pair|
    ray = [point_pair[0], point_pair[1] - point_pair[0]]
    hit_item = model.raytest(point_pair[0], ray)
    if hit_item && hit_item[0]
      has_conflict = true
      break
    end
  end
  
  return has_conflict
end
```

### 6.3 胶带平面创建
为每个无冲突的边界线段创建一个具有一定宽度的矩形平面：
```ruby
def create_tape_for_segment(segment, width, parent_group)
  start_point, end_point = segment
  
  # 检查是否有冲突
  if check_segment_conflict(segment, width, parent_group)
    puts "检测到边界线段存在冲突，跳过胶带创建"
    return nil
  end
  
  # 计算线段方向向量
  direction = end_point - start_point
  length = direction.length
  
  # 计算垂直于线段的单位向量
  perpendicular = Geom::Vector3d.new(-direction.y, direction.x, 0)
  perpendicular.normalize!
  
  # 计算胶带四个角点
  half_width = width / 2.0
  p1 = start_point.offset(perpendicular, half_width)
  p2 = start_point.offset(perpendicular, -half_width)
  p3 = end_point.offset(perpendicular, -half_width)
  p4 = end_point.offset(perpendicular, half_width)
  
  # 创建胶带面
  face = parent_group.entities.add_face([p1, p2, p3, p4])
  
  face
end
```

### 6.4 高度处理
将胶带平面拉高到适当高度：
```ruby
def elevate_tape(tape_face, height)
  # 上浮胶带面
  tape_face.pushpull(height)
end
```

### 6.5 材质应用
应用胶带材质：
```ruby
def apply_tape_material(tape_face)
  # 应用胶带颜色
  tape_face.material = TAPE_COLOR
  tape_face.back_material = TAPE_COLOR
end
```

## 7. 使用流程

### 7.1 单个区域胶带生成
```ruby
# 为单个区域生成胶带
zone_data = {
  "id" => "zone2",
  "name" => "办公区域",
  "shape" => {
    "type" => "polygon",
    "points" => [
      [0, 0, 0],
      [5, 0, 0],
      [5, 5, 0],
      [0, 5, 0]
    ]
  }
}

TapeBuilder.generate_zone_tape(zone_data, parent_group)
```

### 7.2 批量处理多个区域
```ruby
# 批量处理多个区域（每次处理一个）
zones_data.each do |zone_data|
  TapeBuilder.generate_zone_tape(zone_data, parent_group)
end
```

## 8. 错误处理

### 8.1 数据验证
- 检查区域数据的完整性
- 验证shape和points的有效性
- 确保区域点数足够

### 8.2 几何验证
- 检查线段长度是否有效
- 验证胶带面的有效性
- 处理退化情况（如点重合）

### 8.3 冲突处理
- 记录被跳过的边界线段
- 提供冲突统计信息
- 可选的冲突可视化功能

### 8.4 异常捕获
- 使用begin-rescue块包装主要操作
- 提供详细的错误日志
- 确保程序在出错时能够继续运行

## 9. 性能考虑

### 9.1 算法优化
- 高效的边界提取算法
- 优化的冲突检测策略
- 合理的几何计算

### 9.2 内存管理
- 及时清理临时变量
- 避免创建过多中间对象
- 使用适当的数据结构

### 9.3 渲染优化
- 单区域处理减少模型重绘
- 优化材质应用
- 减少不必要的几何计算

## 10. 扩展性

### 10.1 胶带类型扩展
- 支持不同颜色的胶带
- 可添加不同宽度的胶带
- 支持特殊区域的定制胶带

### 10.2 材质系统扩展
- 支持更复杂的胶带材质
- 可添加纹理和图案
- 支持动态材质变化

### 10.3 功能扩展
- 支持胶带的交互操作
- 可添加胶带标签和注释
- 支持胶带的动态更新
- 提供冲突可视化选项

--- 