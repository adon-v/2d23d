# 流生成功能设计文档

## 1. 功能概述

流生成功能是工厂布局导入系统的重要组成部分，负责创建和管理工厂内的物流通道和流程路径。该功能支持复杂的流路径生成，包括多段连接、宽度变化和颜色标识，为工厂的物流规划提供可视化支持。

## 2. 设计思路

### 2.1 核心设计理念
- **多段流路径**：支持由多个子流段组成的复杂路径
- **动态宽度**：每个流段可以有不同的宽度
- **颜色标识**：为不同的流分配不同的颜色
- **几何计算**：精确计算流通道的边界和形状

### 2.2 流类型分类
1. **物流通道**：用于物料运输的通道
   - 支持不同宽度的通道段
   - 平滑的路径连接
2. **流程路径**：用于工艺流程的路径
   - 可视化工艺流程
   - 颜色编码标识

### 2.3 处理流程
1. **数据验证**：检查流数据的有效性
2. **中心线计算**：计算流路径的中心线
3. **边界计算**：根据宽度计算流的边界
4. **多边形生成**：生成流通道的多边形形状
5. **实体创建**：在SketchUp中创建流通道实体
6. **颜色应用**：为流通道应用颜色标识

## 3. 模块结构

### 3.1 FlowBuilder模块

#### 主要功能
- 批量流导入
- 多段流路径生成
- 动态宽度处理
- 颜色标识管理

#### 核心函数说明

**`import_flows(flows_data, parent_group)`**
- **作用**：批量导入所有流
- **参数**：流数据数组、父组对象
- **前置条件**：流数据包含有效的child_flows数组

**`create_flow_channel(center_points, widths, color, parent_group)`**
- **作用**：创建单个流通道
- **参数**：中心线点集、宽度数组、颜色、父组
- **前置条件**：中心线点数至少为2个

**`calculate_flow_boundaries(center_points, widths)`**
- **作用**：计算流通道的边界
- **参数**：中心线点集、宽度数组
- **返回**：左右边界线数组

**`generate_flow_polygon(left_lines, right_lines)`**
- **作用**：生成流通道的多边形
- **参数**：左边界线、右边界线
- **返回**：多边形顶点数组

## 4. 配置参数

### 4.1 流颜色配置
```ruby
# 流的颜色定义
FLOW_COLORS = [
  [255, 0, 0],      # 红色
  [0, 128, 0],      # 绿色
  [0, 0, 255],      # 蓝色
  [255, 128, 0],    # 橙色
  [128, 0, 255],    # 紫色
  [0, 200, 200],    # 青色
  [200, 200, 0],    # 黄色
  [255, 0, 128],    # 粉色
  [128, 128, 0]     # 橄榄色
]

# 箭头颜色
ARROW_COLOR = [0, 255, 0]  # 绿色
```

### 4.2 几何计算参数
```ruby
# 流通道参数
DEFAULT_FLOW_WIDTH = 3.0        # 默认流宽度（米）
MIN_FLOW_WIDTH = 0.5            # 最小流宽度（米）
MAX_FLOW_WIDTH = 20.0           # 最大流宽度（米）

# 几何验证阈值
MIN_VECTOR_LENGTH = 0.001       # 最小向量长度
MIN_FLOW_LENGTH = 0.001         # 最小流长度
INTERSECTION_TOLERANCE = 1e-6   # 交点计算容差
```

### 4.3 单位转换参数
```ruby
# 单位转换
MILLIMETER_TO_INCH = 0.0393701  # 毫米转英寸
INCH_TO_MILLIMETER = 25.4       # 英寸转毫米

# 尺寸验证
MIN_SEGMENT_COUNT = 1           # 最小流段数量
MAX_SEGMENT_COUNT = 1000        # 最大流段数量
```

## 5. 前置条件

### 5.1 数据要求
- 流数据必须包含有效的child_flows数组
- 每个流段必须包含start和end坐标
- 流段宽度数据（可选，有默认值）
- 所有坐标必须是有效的数值

### 5.2 环境要求
- SketchUp环境已初始化
- 父组对象存在且有效
- 模型处于可编辑状态

### 5.3 依赖模块
- `Utils`模块：提供点验证、数值解析和几何计算
- `Geom`模块：提供几何计算功能
- SketchUp API：提供实体创建功能

## 6. 关键代码展示

### 6.1 流导入主流程
```ruby
def self.import_flows(flows_data, parent_group)
  flows_data.each_with_index do |flow, idx|
    color = FLOW_COLORS[idx % FLOW_COLORS.size]
    arrow_color = [0, 255, 0]
    segments = flow["child_flows"] || []
    puts "【通道测试】flow[#{idx}] child_flows 数量: #{segments.size}"
    
    if !segments.is_a?(Array) || segments.empty?
      puts "【通道测试】警告: 当前flow没有有效的child_flows，无法生成通道"
      next
    end

    # 收集中心线点和宽度
    center_points = []
    widths = []
    
    segments.each_with_index do |seg, i|
      sp = Utils.validate_and_create_point(seg["start"])
      ep = Utils.validate_and_create_point(seg["end"])
      width = Utils.parse_number(seg["width"] / 25.4 || 3.0)
      width = 0.5 if width.nil? || width <= 0
      
      unless sp && ep
        puts "【通道测试】警告: flow段无效，start=#{seg['start'].inspect}, end=#{seg['end'].inspect}"
        next
      end
      
      sp.z = 0; ep.z = 0
      
      if i == 0
        center_points << sp
        widths << width
      end
      
      if center_points.empty? || (ep.distance(center_points[-1]) > 1e-6)
        center_points << ep
        widths << width
      end
    end
    
    center_points = center_points.compact
    widths = widths[0, center_points.size]
    
    if center_points.size < 2
      puts "【通道测试】警告: 通道中心线点数不足，无法生成通道"
      next
    end

    # 创建流通道
    create_flow_channel(center_points, widths, color, parent_group)
  end
end
```

### 6.2 流边界计算
```ruby
def self.calculate_flow_boundaries(center_points, widths)
  # 计算每个点的"左/右边界线"
  left_lines = []
  right_lines = []
  n = center_points.size
  
  (0...n-1).each do |i|
    p1 = center_points[i]
    p2 = center_points[i+1]
    w = widths[i] || widths[0]
    dir = p2 - p1
    
    begin
      dir = dir.normalize
    rescue
      dir = Geom::Vector3d.new(1, 0, 0)
    end
    
    normal = Geom::Vector3d.new(-dir.y, dir.x, 0)
    
    begin
      normal = normal.normalize
    rescue
      normal = Geom::Vector3d.new(1, 0, 0)
    end
    
    left_lines << [p1.offset(normal, w/2.0), p2.offset(normal, w/2.0)]
    right_lines << [p1.offset(normal.reverse, w/2.0), p2.offset(normal.reverse, w/2.0)]
  end
  
  [left_lines, right_lines]
end
```

### 6.3 流多边形生成
```ruby
def self.generate_flow_polygon(left_lines, right_lines)
  # 计算多边形顶点（交点法）
  left_pts = []
  right_pts = []
  
  # 左边界
  left_pts << left_lines[0][0]
  (1...left_lines.size).each do |i|
    pt = Utils.line_intersection_2d(left_lines[i-1][0], left_lines[i-1][1], left_lines[i][0], left_lines[i][1])
    left_pts << (pt || left_lines[i][0])
  end
  left_pts << left_lines[-1][1]
  
  # 右边界
  right_pts << right_lines[0][0]
  (1...right_lines.size).each do |i|
    pt = Utils.line_intersection_2d(right_lines[i-1][0], right_lines[i-1][1], right_lines[i][0], right_lines[i][1])
    right_pts << (pt || right_lines[i][0])
  end
  right_pts << right_lines[-1][1]
  
  # 组合成多边形：左边界 + 右边界（反向）
  polygon_points = left_pts + right_pts.reverse
  
  # 去重并保持顺序
  unique_points = []
  polygon_points.each do |point|
    if unique_points.empty? || point.distance(unique_points[-1]) > 1e-6
      unique_points << point
    end
  end
  
  unique_points
end
```

### 6.4 流通道创建
```ruby
def self.create_flow_channel(center_points, widths, color, parent_group)
  puts "【通道测试】开始创建流通道，中心线点数: #{center_points.size}"
  
  # 计算流边界
  left_lines, right_lines = calculate_flow_boundaries(center_points, widths)
  
  # 生成流多边形
  polygon_points = generate_flow_polygon(left_lines, right_lines)
  
  if polygon_points.size < 3
    puts "【通道测试】警告: 流多边形点数不足，无法创建通道"
    return
  end
  
  # 创建流通道组
  flow_group = parent_group.entities.add_group
  flow_group.name = "Flow_#{rand(10000)}"
  
  # 创建流通道面
  flow_face = flow_group.entities.add_face(polygon_points)
  
  if flow_face
    # 设置流通道材质
    flow_face.material = color
    flow_face.back_material = color
    
    # 设置流通道属性
    flow_face.set_attribute('FactoryImporter', 'flow_type', 'channel')
    flow_face.set_attribute('FactoryImporter', 'flow_color', color)
    flow_face.set_attribute('FactoryImporter', 'center_points_count', center_points.size)
    
    # 为流通道添加厚度
    flow_face.pushpull(0.01)  # 1cm厚度
    
    puts "【通道测试】流通道创建成功，点数: #{polygon_points.size}"
  else
    puts "【通道测试】警告: 流通道面创建失败"
  end
end
```

### 6.5 线段交点计算
```ruby
def self.calculate_line_intersection(p1, p2, q1, q2)
  x1, y1 = p1.x, p1.y
  x2, y2 = p2.x, p2.y
  x3, y3 = q1.x, q1.y
  x4, y4 = q2.x, q2.y
  
  # 计算分母
  denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)
  
  # 检查是否平行
  return nil if denom.abs < 1e-10
  
  # 计算参数
  ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom.to_f
  ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom.to_f
  
  # 检查参数是否在有效范围内
  return nil if ua < -0.1 || ua > 1.1 || ub < -0.1 || ub > 1.1
  
  # 计算交点坐标
  x = x1 + ua * (x2 - x1)
  y = y1 + ua * (y2 - y1)
  
  Geom::Point3d.new(x, y, 0)
end
```

## 7. 使用流程

### 7.1 基本使用
```ruby
# 批量导入流
flows_data = [
  {
    "id" => "flow1",
    "name" => "主物流通道",
    "child_flows" => [
      {
        "start" => [0, 0, 0],
        "end" => [10, 0, 0],
        "width" => 3000
      },
      {
        "start" => [10, 0, 0],
        "end" => [10, 10, 0],
        "width" => 2500
      }
    ]
  }
]

FlowBuilder.import_flows(flows_data, parent_group)
```

### 7.2 单独创建流通道
```ruby
# 创建单个流通道
center_points = [
  Geom::Point3d.new(0, 0, 0),
  Geom::Point3d.new(10, 0, 0),
  Geom::Point3d.new(10, 10, 0)
]

widths = [3.0, 2.5, 2.0]
color = [255, 0, 0]  # 红色

FlowBuilder.create_flow_channel(center_points, widths, color, parent_group)
```

### 7.3 计算流边界
```ruby
# 计算流边界
left_lines, right_lines = FlowBuilder.calculate_flow_boundaries(center_points, widths)

# 生成流多边形
polygon_points = FlowBuilder.generate_flow_polygon(left_lines, right_lines)
```

## 8. 错误处理

### 8.1 数据验证
- 检查流数据的完整性
- 验证流段坐标的有效性
- 确保流段数量合理

### 8.2 几何验证
- 检查中心线向量的有效性
- 验证边界计算的正确性
- 确保多边形生成成功

### 8.3 异常捕获
- 使用begin-rescue块包装主要操作
- 提供详细的错误日志
- 确保程序在出错时能够继续运行

## 9. 性能考虑

### 9.1 算法优化
- 高效的边界计算算法
- 优化的交点计算
- 合理的多边形生成

### 9.2 内存管理
- 及时清理临时变量
- 避免创建过多中间对象
- 使用适当的数据结构

### 9.3 渲染优化
- 批量处理流创建
- 优化材质应用
- 减少不必要的几何计算

## 10. 扩展性

### 10.1 流类型扩展
- 支持更多流类型（单向流、双向流等）
- 可添加流的方向标识
- 支持流的动态更新

### 10.2 几何算法扩展
- 支持更复杂的流路径
- 可添加流的装饰元素
- 支持流的自动优化

### 10.3 功能扩展
- 支持流的交互操作
- 可添加流标签和注释
- 支持流的统计分析

---
