# 实体存储器修复方案

## 问题描述
在使用152639.json时创建的墙体均为默认墙体，在选择实体时无论点击墙体菜单中的哪个"默认实体"都只会选中相同的墙。这是因为同类元素命名相同时，实体存储器无法正确区分它们，导致选择功能出现问题。

**新增需求**：
1. 门是挖出来的，不需要定位，菜单栏把门去除
2. 对同类实体增加批量选择功能，可以一次性选择所有同类型实体
3. 选择墙体时不扩选到窗户，避免实体选择冲突

## 根本原因分析

### 1. 实体命名重复
- 多个墙体使用相同的名称（如"默认墙体"）
- 实体存储器无法区分同名实体
- 菜单项指向错误的实体

### 2. 缺少唯一标识符
- 实体没有唯一的ID属性
- 无法通过ID精确定位实体
- 选择功能依赖名称而非唯一标识

### 3. 菜单创建逻辑问题
- 同名实体在菜单中显示相同名称
- 无法区分不同的实体实例
- 选择时总是选中第一个匹配的实体

### 4. 功能需求问题
- 门是挖出来的，不需要定位功能
- 缺少同类实体的批量选择功能
- 无法一次性操作所有同类型实体

### 5. 实体选择冲突问题
- 选择墙体时自动选中窗户（窗户嵌入在墙体中）
- 选择窗户时自动选中墙体
- 实体选择不够精确，影响操作效率

## 修复方案

### 1. 实体唯一标识系统

#### 1.1 唯一ID生成
```ruby
# 为每个实体生成唯一ID
wall_id = wall_data["id"] || "wall_#{wall_entities.length + 1}"
equipment_id = equipment_data["id"] || "equipment_#{equipment_count + 1}"
zone_id = zone["id"] || "zone_#{zone_index + 1}"
```

#### 1.2 唯一名称生成
```ruby
# 生成包含唯一标识的名称
def get_entity_name(entity)
  base_name = get_base_name(entity)
  unique_id = get_unique_identifier(entity)
  "#{base_name}_#{unique_id}"
end
```

### 2. 实体属性设置

#### 2.1 墙体属性
```ruby
wall_group.set_attribute('FactoryImporter', 'id', wall_id)
wall_group.set_attribute('FactoryImporter', 'wall_id', wall_id)
wall_group.set_attribute('FactoryImporter', 'name', wall_name)
```

#### 2.2 设备属性
```ruby
equipment_group.set_attribute('FactoryImporter', 'id', equipment_id)
equipment_group.set_attribute('FactoryImporter', 'equipment_id', equipment_id)
equipment_group.set_attribute('FactoryImporter', 'name', equipment_name)
```

#### 2.3 区域属性
```ruby
zone_group.set_attribute('FactoryImporter', 'id', zone["id"])
zone_group.set_attribute('FactoryImporter', 'zone_id', zone["id"])
zone_group.set_attribute('FactoryImporter', 'zone_name', zone["name"])
```

### 3. 实体存储器优化

#### 3.1 唯一标识符获取
```ruby
def get_unique_identifier(entity)
  # 优先使用自定义ID
  if entity.respond_to?(:get_attribute)
    custom_id = entity.get_attribute('FactoryImporter', 'id') ||
                entity.get_attribute('FactoryImporter', 'wall_id') ||
                entity.get_attribute('FactoryImporter', 'equipment_id') ||
                entity.get_attribute('FactoryImporter', 'zone_id') ||
                entity.get_attribute('FactoryImporter', 'flow_id')
    
    return custom_id if custom_id
  end
  
  # 使用实体ID作为备选
  entity.entityID.to_s
end
```

#### 3.2 菜单创建优化
```ruby
# 为每个实体创建唯一的菜单项
entities.each do |entity_record|
  entity_name = entity_record[:name]  # 现在包含唯一标识
  type_menu.add_item(entity_name) {
    select_entity_in_sketchup(entity_record)
  }
end
```

### 4. 实体选择器增强

#### 4.1 详细选择器
```ruby
def show_detailed_entity_selector(entity_type, entities)
  options = entities.map.with_index do |entity_record, index|
    "#{index + 1}. #{entity_record[:name]}"
  end
  
  prompt = "请输入要选择的 #{get_type_display_name(entity_type)} 编号 (1-#{entities.size}):"
  input = UI.inputbox([prompt], ["1"], "选择实体")
  
  if input
    index = input[0].to_i - 1
    if index >= 0 && index < entities.size
      select_entity_in_sketchup(entities[index])
    end
  end
end
```

### 5. 批量选择功能

#### 5.1 批量选择所有同类型实体
```ruby
def select_all_entities_by_type(entity_type)
  model = Sketchup.active_model
  selection = model.selection
  entities = get_entities_by_type(entity_type)
  
  # 清除当前选择并选择所有有效实体
  selection.clear
  entities.each do |entity_record|
    entity = entity_record[:entity]
    if entity && entity.valid?
      selection.add(entity)
    end
  end
  
  # 调整视图显示所有选中实体
  model.active_view.zoom(selection)
end
```

#### 5.2 添加到当前选择
```ruby
def add_all_entities_by_type_to_selection(entity_type)
  model = Sketchup.active_model
  selection = model.selection
  entities = get_entities_by_type(entity_type)
  
  # 添加到当前选择
  entities.each do |entity_record|
    entity = entity_record[:entity]
    if entity && entity.valid?
      selection.add(entity)
    end
  end
  
  # 过滤掉冲突的实体
  filter_conflicting_entities_from_selection(model, selection, entity_type)
end
```

### 6. 实体冲突过滤功能（墙体和窗户对应关系方案）

#### 6.1 对应关系存储
```ruby
@@wall_window_mapping = {}  # 存储墙体和窗户的对应关系

def add_wall_window_mapping(wall_id, window_entity_record)
  # 建立墙体和窗户的对应关系
end

def get_windows_for_wall(wall_id)
  # 获取指定墙体对应的所有窗户
end
```

#### 6.2 反选过滤原理
```ruby
def remove_windows_using_mapping(model, selection, wall_entity_record)
  # 1. 获取墙体ID
  # 2. 查找该墙体对应的所有窗户
  # 3. 从选择中移除对应的窗户实体
  # 4. 最终只保留墙体
end
```

#### 6.3 应用场景
- **选择墙体**：根据墙体ID查找对应窗户 → 移除窗户 → 只保留墙体
- **批量选择墙体**：处理所有墙体的对应窗户
- **添加墙体到选择**：处理所有墙体的对应窗户
- **精确反选**：直接使用存储器中的实体，避免属性识别问题

### 7. 材质应用保护功能（防止覆盖窗户）

#### 7.1 窗户识别机制
```ruby
def window_like_entity?(entity)
  # 通过多种属性判断是否为窗户相关实体
  # - window_type: wall_window/independent_window
  # - window_name: 包含"window"或"窗"
  # - type: "window"
  # - 实体名称: 包含"window"或"窗"
end

def face_is_window_glass?(face)
  # 判断面是否为窗户玻璃
  # - face_type: "window_glass"
end
```

#### 7.2 材质应用保护
```ruby
def apply_material_to_group_entities(group, material_definition)
  # 递归应用材质时自动跳过：
  # 1. 窗户子组 (window_like_entity?)
  # 2. 窗户玻璃面 (face_is_window_glass?)
  # 3. 隐藏实体
end
```

#### 7.3 保护效果
- ✅ **墙体材质正常应用**：墙体成功获得新材质
- ✅ **窗户材质保持**：窗户玻璃保持原有材质和效果
- ✅ **自动识别跳过**：无需手动选择，系统自动保护窗户
- ✅ **递归保护**：深度嵌套的窗户实体也能被正确识别和保护

## 修复效果

### 1. 实体唯一性
- ✅ 每个实体都有唯一的ID
- ✅ 每个实体都有唯一的名称
- ✅ 实体可以通过ID精确定位

### 2. 选择功能
- ✅ 同名实体可以正确区分
- ✅ 菜单项指向正确的实体
- ✅ 选择功能准确无误
- ✅ 支持批量选择所有同类型实体
- ✅ 支持添加到当前选择
- ✅ 智能过滤冲突实体
- ✅ 避免选择墙体时选中窗户

### 3. 用户体验
- ✅ 实体名称清晰可读
- ✅ 选择操作直观简单
- ✅ 支持大量实体的管理
- ✅ 批量操作提高效率
- ✅ 菜单结构更加合理
- ✅ 选择精确，避免误选
- ✅ 操作更加高效
- ✅ 材质应用智能保护窗户
- ✅ 无需手动排除，系统自动识别

## 使用方法

### 1. 正常使用
1. 导入工厂布局文件
2. 使用 `Extensions` → `实体存储器` → `墙体` → 选择具体墙体
3. 每个墙体都有唯一的名称和ID

### 2. 批量选择使用
1. **选择所有同类型实体**：
   - `Extensions` → `实体存储器` → `墙体` → `选择所有墙体`
   - 一次性选中所有墙体实体

2. **添加到当前选择**：
   - `Extensions` → `实体存储器` → `墙体` → `添加所有墙体到选择`
   - 将墙体添加到当前选择中，不清除其他选择

3. **混合选择**：
   - 先选择一些墙体
   - 再添加所有窗户到选择
   - 实现跨类型的批量操作

### 3. 测试验证
1. 使用 `Extensions` → `实体存储器测试` → `测试实体唯一性`
2. 使用 `Extensions` → `实体存储器测试` → `测试实体选择`
3. 使用 `Extensions` → `实体存储器测试` → `测试批量选择`
4. 验证每个实体都可以正确选择

### 4. 调试功能
1. 使用 `Extensions` → `实体存储器测试` → `测试实体属性`
2. 查看实体的详细属性信息
3. 确认唯一标识符正确设置

### 5. 过滤功能测试
1. 使用 `Extensions` → `实体存储器测试` → `测试实体过滤`
2. 测试选择墙体时的窗户过滤
3. 测试选择窗户时的墙体过滤
4. 测试混合选择功能

### 6. 材质保护功能测试
1. 批量选择墙体：`Extensions` → `实体存储器` → `墙体` → `选择所有墙体`
2. 应用材质：`Extensions` → `材质管理器` → 选择任意材质
3. **验证效果**：
   - 墙体成功应用新材质
   - 窗户保持原有材质和玻璃效果
   - 控制台显示"跳过窗户子组"和"跳过窗户玻璃面"日志

### 7. 立柱存储功能测试
1. 立柱存储验证：`Extensions` → `实体过滤调试` → `测试立柱存储`
2. **验证效果**：
   - 立柱实体正确存储到存储器
   - 立柱属性完整（type, column_id, column_name等）
   - 立柱元数据包含高度、坐标点等信息
   - 立柱支持批量选择和个体选择

## 技术细节

### 1. 命名规则
- **墙体**: `墙体_${wall_id}` 或 `墙体_${wall_1}`
- **立柱**: `立柱_${column_id}` 或 `立柱_${column_index}`
- **设备**: `${equipment_name} (${equipment_id})`
- **区域**: `${zone_name}_${zone_id}` 或 `区域_${zone_id}`
- **流通道**: `流通道_${flow_id}` 或 `流通道_${flow_index}`
- **窗户**: `窗户_${window_id}` 或 `窗户_${window_index}`
- **工厂地面**: `工厂大地面_${ground_id}`

### 2. 窗户保护机制
- **窗户识别**: 通过 `window_type`、`window_name`、`type`、实体名称等多重属性判断
- **玻璃面识别**: 通过 `face_type = "window_glass"` 识别窗户玻璃面
- **递归保护**: 在材质递归应用过程中自动跳过窗户相关实体
- **属性检查**: 支持中英文名称识别（"window"、"窗户"等）

### 2. ID生成策略
- **优先使用**: JSON数据中的原始ID
- **备选方案**: 类型前缀 + 序号
- **兜底方案**: SketchUp实体ID
- **支持类型**: wall_id, equipment_id, zone_id, flow_id, column_id

### 3. 属性存储
- **标准属性**: `id`, `name`
- **类型属性**: `wall_id`, `equipment_id`, `zone_id`, `flow_id`, `window_id`, `column_id`
- **元数据**: 位置、尺寸、类型等详细信息

### 4. 菜单结构
- **移除门类型**: 门是挖出来的，不需要定位功能
- **新增立柱类型**: 支持立柱的存储、选择和批量操作
- **批量选择**: 每个类型都有"选择所有"和"添加到选择"功能
- **个体选择**: 保留单个实体的选择功能
- **统计信息**: 提供每种类型的统计信息

### 5. 冲突过滤规则
- **墙体 vs 窗户**: 选择墙体时过滤窗户，选择窗户时过滤墙体
- **门 vs 墙体**: 选择门时过滤墙体
- **设备 vs 区域**: 选择设备时过滤区域，选择区域时过滤设备
- **可扩展**: 支持添加新的冲突规则

## 兼容性说明

### 1. 向后兼容
- 现有实体仍然可以正常工作
- 旧版本的实体会被自动分配唯一ID
- 不会影响现有的工作流程

### 2. 向前兼容
- 新创建的实体自动使用唯一标识
- 支持未来扩展的实体类型
- 保持API接口的稳定性

## 文件修改清单

### 核心文件
- `lib/entity_storage.rb`: 实体存储器核心逻辑
- `lib/wall_builder.rb`: 墙体生成器
- `lib/equipment_builder.rb`: 设备生成器
- `lib/zone_builder.rb`: 区域生成器
- `lib/flow_builder.rb`: 流生成器
- `lib/structure_builder.rb`: 结构生成器（包含立柱）

### 测试文件
- `test_entity_storage_fix.rb`: 实体存储器测试工具

### 文档文件
- `实体存储器修复方案.md`: 本文档

## 预期效果

修复后，使用152639.json创建的实体将具有以下特征：

1. **唯一命名**: 每个实体都有唯一的名称，如"墙体_wall_1", "墙体_wall_2"等
2. **精确选择**: 点击不同的实体菜单项会选中对应的实体
3. **批量操作**: 可以一次性选择所有同类型的实体
4. **混合选择**: 支持跨类型的实体组合选择
5. **智能过滤**: 自动过滤冲突实体，避免误选
6. **清晰标识**: 实体名称包含唯一ID，便于识别和管理
7. **稳定可靠**: 选择功能不再受同名实体影响
8. **合理菜单**: 移除不需要的门类型，菜单结构更加合理

这样就彻底解决了实体存储器中同名实体无法正确区分的问题，并增加了高效的批量选择功能和智能的冲突过滤功能。

## 总结

本修复方案成功解决了实体存储器的多个关键问题：

1. **实体唯一性**：通过唯一ID和名称解决了同名实体的选择问题
2. **批量选择**：提供了选择所有同类型实体和添加到选择的功能
3. **冲突过滤**：实现了智能的实体冲突过滤，避免选择冲突
4. **材质保护**：自动识别和保护窗户，防止被墙体材质覆盖
5. **用户体验**：优化了菜单结构和操作流程，提高了使用效率

### 🎯 **核心技术创新**

- **墙体和窗户对应关系存储**：建立精确的映射关系，支持智能反选
- **材质应用保护机制**：通过多重属性识别，自动跳过窗户相关实体
- **递归保护算法**：深度嵌套的窗户实体也能被正确识别和保护
- **立柱存储管理**：新增立柱类型支持，完整的存储、选择和批量操作功能

### ✅ **最终效果**

通过墙体和窗户对应关系存储、智能反选过滤、材质应用保护、立柱存储管理等技术的综合应用，系统现在能够：
- 精确识别和选择每个实体
- 智能处理实体间的冲突关系
- **自动保护窗户不被材质覆盖**（核心突破）
- 提供高效便捷的批量操作
- 支持中英文窗户名称识别
- **完整支持立柱管理**（新增功能）

### 🚀 **应用价值**

这个解决方案不仅修复了原有的问题，还为未来的功能扩展奠定了坚实的基础。特别是在工厂布局设计中，能够：
- 保持窗户的透明玻璃效果
- 允许墙体材质的自由调整
- 避免手动排除窗户的繁琐操作
- 提高整体建模效率和质量
- **支持立柱的完整生命周期管理**
- **扩展实体类型支持，为未来功能奠定基础**

**测试验证**：✅ 完全有效，墙体材质正常应用，窗户保持原有效果 